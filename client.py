# -*- generated by 1.0.10 -*-
import da
PatternExpr_461 = da.pat.TuplePattern([da.pat.ConstantPattern('Config Response'), da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)])
PatternExpr_471 = da.pat.FreePattern('olympus')
PatternExpr_524 = da.pat.TuplePattern([da.pat.ConstantPattern('Config Response'), da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)])
PatternExpr_534 = da.pat.FreePattern('olympus')
PatternExpr_1472 = da.pat.ConstantPattern('Done')
PatternExpr_1476 = da.pat.FreePattern('tail')
PatternExpr_1492 = da.pat.TuplePattern([da.pat.ConstantPattern('Forward Result to Client'), da.pat.FreePattern('result'), da.pat.FreePattern('result_proof'), da.pat.FreePattern('reqId')])
PatternExpr_1503 = da.pat.FreePattern('tail')
PatternExpr_1675 = da.pat.TuplePattern([da.pat.ConstantPattern('Config Response'), da.pat.FreePattern('replicas'), da.pat.FreePattern('head'), da.pat.FreePattern('tail'), da.pat.FreePattern('isValidConfigPresent'), da.pat.FreePattern('replicaPublicKeys')])
PatternExpr_1685 = da.pat.FreePattern('olympus')
PatternExpr_1750 = da.pat.TuplePattern([da.pat.ConstantPattern('Retransmitted Response'), da.pat.FreePattern('result'), da.pat.FreePattern('operation_object'), da.pat.FreePattern('result_proof'), da.pat.FreePattern('replica'), da.pat.FreePattern('responseCode'), da.pat.FreePattern('signed_workload')])
PatternExpr_1767 = da.pat.FreePattern('p')
PatternExpr_1951 = da.pat.TuplePattern([da.pat.ConstantPattern('Result from olympus'), da.pat.FreePattern('result'), da.pat.FreePattern('reqId')])
PatternExpr_1960 = da.pat.FreePattern('olympus')
_config_object = {'channel': {'fifo', 'reliable'}, 'clock': 'lamport'}
import sys
import os
import time
import random
import string
from utils import Utils
from datetime import datetime
from operation import Operation

class Client(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ClientReceivedEvent_0 = []
        self._ClientReceivedEvent_1 = []
        self._ClientReceivedEvent_2 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_0', PatternExpr_461, sources=[PatternExpr_471], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_1', PatternExpr_524, sources=[PatternExpr_534], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_2', PatternExpr_1472, sources=[PatternExpr_1476], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_3', PatternExpr_1492, sources=[PatternExpr_1503], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1491]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_4', PatternExpr_1675, sources=[PatternExpr_1685], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1674]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_5', PatternExpr_1750, sources=[PatternExpr_1767], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1749]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_6', PatternExpr_1951, sources=[PatternExpr_1960], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1950])])

    def setup(self, olympus, clientId, olympusPublicKey, workload_for_client, clientPrivateKey, client_timeout, **rest_1998):
        super().setup(olympus=olympus, clientId=clientId, olympusPublicKey=olympusPublicKey, workload_for_client=workload_for_client, clientPrivateKey=clientPrivateKey, client_timeout=client_timeout, **rest_1998)
        self._state.olympus = olympus
        self._state.clientId = clientId
        self._state.olympusPublicKey = olympusPublicKey
        self._state.workload_for_client = workload_for_client
        self._state.clientPrivateKey = clientPrivateKey
        self._state.client_timeout = client_timeout
        self._state.olympus = self._state.olympus
        self._state.clientId = self._state.clientId
        self._state.olympusPublicKey = self._state.olympusPublicKey
        self._state.replicaPublicKeys = []
        self._state.workload_for_client = self._state.workload_for_client
        self._state.clientPrivateKey = self._state.clientPrivateKey
        self._state.head = None
        self._state.tail = None
        self._state.client_timeout = self._state.client_timeout
        self._state.requestId = (- 1)
        self._state.replicas = None
        self._state.isValidConfigPresent = False
        self._state.completedRequests = {}
        self._state.requestToResult = {}
        self._state.runningstate = {}
        self._state.utils = Utils()
        self._state.someRequestOutputFailed = False
        self._state.periodic_interval = 2
        self._state.errorresponsecode = False
        self._state.distinct_replicas = []

    def run(self):
        self.output((('********Starting Client' + str(self._id)) + '*****'))
        start_time = datetime.now()
        self.output((('Client ' + str(self._id)) + 'Started: '), start_time.second)
        workloads = self._state.workload_for_client.split(';')
        self.output(((('Client ' + str(self._id)) + ' workload ->') + str(workloads)))
        for workload in workloads:
            self.retry_for_current_configuration()
            workload = workload.strip().replace("'", '')
            self._state.errorresponsecode = False
            self._state.requestId += 1
            requestIdFinal = ((self._state.clientId + ':') + str(self._state.requestId))
            operation = workload.split('(')[0]
            key_value = workload[(workload.find('(') + 1):workload.find(')')]
            if (operation == 'pseudorandom'):
                key = key_value.split(',')
                self.execute_pseudorandom_workloads(int(key[0]), int(key[1]))
            else:
                key = key_value.split(',')
                self.execute_workload(operation, key, requestIdFinal, workload)
        self.output((('Checking Expected Dictionary Content at completion of all workloads for ' + str(self._id)) + '.........'))
        checkFlag = True
        for (key, value) in self._state.requestToResult.items():
            if (key in self._state.completedRequests):
                if (not (value == self._state.completedRequests[key][0])):
                    checkFlag = False
                    self._state.someRequestOutputFailed = True
                    self.output(((((((('Workload with requestId: ' + str(key)) + ' Failed for Client: ') + str(self._id)) + 'Expected value is: ') + str(value)) + 'Actual value is: ') + str(self._state.completedRequests[key][0])))
            else:
                checkFlag = False
                self._state.someRequestOutputFailed = True
                self.output(((((('Workload with requestId: ' + str(key)) + ' Failed for Client: ') + str(self._id)) + 'Expected value is: ') + str(value)))
        if (checkFlag == True):
            self.output((('Client ' + str(self._id)) + ' finised executing all workloads successfully.'))
        else:
            self.output((('Client ' + str(self._id)) + ' finised with some request failed.'))
        super()._label('_st_label_1469', block=False)
        tail = None

        def ExistentialOpExpr_1470():
            nonlocal tail
            for (_, (_, _, self._state.tail), _ConstantPattern1485_) in self._ClientReceivedEvent_2:
                if (_ConstantPattern1485_ == 'Done'):
                    if True:
                        return True
            return False
        _st_label_1469 = 0
        while (_st_label_1469 == 0):
            _st_label_1469 += 1
            if ExistentialOpExpr_1470():
                _st_label_1469 += 1
            else:
                super()._label('_st_label_1469', block=True)
                _st_label_1469 -= 1

    def getResult(self, operation, key, value):
        output = 'None'
        if (operation == 'put'):
            self._state.runningstate[key] = value
            output = 'OK'
        elif (operation == 'get'):
            if (key in self._state.runningstate):
                output = self._state.runningstate[key]
            else:
                output = ''
        elif (operation == 'slice'):
            if (key in self._state.runningstate):
                (i, j) = value.split(':')
                val = self._state.runningstate[key]
                if ((int(j) < len(val)) and (int(i) >= 0)):
                    self._state.runningstate[key] = val[int(i):int(j)]
                    output = 'OK'
                else:
                    output = 'Fail'
        elif (operation == 'append'):
            if (key in self._state.runningstate):
                self._state.runningstate[key] += str(value)
                output = 'OK'
            else:
                output = 'Fail'
        return output

    def retry_for_current_configuration(self):
        self.send(('Get Current Config', self._state.clientId), to=self._state.olympus)
        super()._label('_st_label_458', block=False)
        olympus = None

        def ExistentialOpExpr_459():
            nonlocal olympus
            for (_, (_, _, self._state.olympus), (_ConstantPattern481_, _, _, _, _, _)) in self._ClientReceivedEvent_0:
                if (_ConstantPattern481_ == 'Config Response'):
                    if True:
                        return True
            return False
        _st_label_458 = 0
        while (_st_label_458 == 0):
            _st_label_458 += 1
            if ExistentialOpExpr_459():
                _st_label_458 += 1
            else:
                super()._label('_st_label_458', block=True)
                _st_label_458 -= 1
        while (not self._state.isValidConfigPresent):
            super()._label('_st_label_496', block=False)
            _st_label_496 = 0
            self._timer_start()
            while (_st_label_496 == 0):
                _st_label_496 += 1
                if self._state.isValidConfigPresent:
                    break
                    _st_label_496 += 1
                elif self._timer_expired:
                    self.output((('Client ' + str(self._id)) + 'Periodically checking olympus if there is any new configuration'))
                    self.send(('Get Current Config', self._state.clientId), to=self._state.olympus)
                    super()._label('_st_label_521', block=False)
                    olympus = None

                    def ExistentialOpExpr_522():
                        nonlocal olympus
                        for (_, (_, _, self._state.olympus), (_ConstantPattern544_, _, _, _, _, _)) in self._ClientReceivedEvent_1:
                            if (_ConstantPattern544_ == 'Config Response'):
                                if True:
                                    return True
                        return False
                    _st_label_521 = 0
                    while (_st_label_521 == 0):
                        _st_label_521 += 1
                        if ExistentialOpExpr_522():
                            _st_label_521 += 1
                        else:
                            super()._label('_st_label_521', block=True)
                            _st_label_521 -= 1
                    else:
                        if (_st_label_521 != 2):
                            continue
                    if (_st_label_521 != 2):
                        break
                    _st_label_496 += 1
                else:
                    super()._label('_st_label_496', block=True, timeout=self._state.periodic_interval)
                    _st_label_496 -= 1
            else:
                if (_st_label_496 != 2):
                    continue
            if (_st_label_496 != 2):
                break

    def execute_workload(self, operation, key, requestIdFinal, workload):
        operation_object = Operation()
        operation_object.requestId = requestIdFinal
        operation_object.command = operation
        tempRequestId = requestIdFinal
        self.output('-------------------------------------------------------------------------------------')
        self.output(((('Executing New workoad from Client: ' + str(self._id)) + ' for RequestId: ') + requestIdFinal))
        signed_workload = self._state.utils.getSignedStatement(self._state.clientPrivateKey, str(workload.replace(' ', '').strip()))
        if (len(key) == 1):
            self._state.requestToResult[requestIdFinal] = self.getResult(operation, key[0], None)
            operation_object.key = key[0]
            operation_object.value = ''
            self.send(('Execute Operation Of Client', operation_object, self._id, signed_workload), to=self._state.head)
            super()._label('_st_label_643', block=False)
            _st_label_643 = 0
            self._timer_start()
            while (_st_label_643 == 0):
                _st_label_643 += 1
                if (tempRequestId in self._state.completedRequests):
                    pass
                    _st_label_643 += 1
                elif self._timer_expired:
                    self._state.isValidConfigPresent = False
                    self.output(((('Client Timeout occured: ' + str(self._id)) + ' for requestid: ') + requestIdFinal))
                    self._state.distinct_replicas = []
                    self.retry_for_current_configuration()
                    self.send(('Retransmit Request To Replicas', operation_object, self._id, signed_workload), to=self._state.replicas)
                    while True:
                        super()._label('_st_label_687', block=False)
                        _st_label_687 = 0
                        self._timer_start()
                        while (_st_label_687 == 0):
                            _st_label_687 += 1
                            if (tempRequestId in self._state.completedRequests):
                                self._state.distinct_replicas = []
                                break
                                _st_label_687 += 1
                            elif self._timer_expired:
                                self._state.distinct_replicas = []
                                self.retry_for_current_configuration()
                                self.send(('Retransmit Request To Replicas', operation_object, self._id, signed_workload), to=self._state.replicas)
                                _st_label_687 += 1
                            else:
                                super()._label('_st_label_687', block=True, timeout=self._state.client_timeout)
                                _st_label_687 -= 1
                        else:
                            if (_st_label_687 != 2):
                                continue
                        if (_st_label_687 != 2):
                            break
                    _st_label_643 += 1
                else:
                    super()._label('_st_label_643', block=True, timeout=self._state.client_timeout)
                    _st_label_643 -= 1
        else:
            self._state.requestToResult[requestIdFinal] = self.getResult(operation, key[0], key[1])
            operation_object.key = key[0]
            operation_object.value = key[1]
            self.send(('Execute Operation Of Client', operation_object, self._id, signed_workload), to=self._state.head)
            super()._label('_st_label_754', block=False)
            _st_label_754 = 0
            self._timer_start()
            while (_st_label_754 == 0):
                _st_label_754 += 1
                if (tempRequestId in self._state.completedRequests):
                    pass
                    _st_label_754 += 1
                elif self._timer_expired:
                    self._state.isValidConfigPresent = False
                    self.output(((('Client Timeout occured: ' + str(self._id)) + ' for requestid: ') + requestIdFinal))
                    self._state.distinct_replicas = []
                    self.retry_for_current_configuration()
                    self.send(('Retransmit Request To Replicas', operation_object, self._id, signed_workload), to=self._state.replicas)
                    while True:
                        super()._label('_st_label_798', block=False)
                        _st_label_798 = 0
                        self._timer_start()
                        while (_st_label_798 == 0):
                            _st_label_798 += 1
                            if (tempRequestId in self._state.completedRequests):
                                self._state.distinct_replicas = []
                                break
                                _st_label_798 += 1
                            elif self._timer_expired:
                                self._state.distinct_replicas = []
                                self.retry_for_current_configuration()
                                self.send(('Retransmit Request To Replicas', operation_object, self._id, signed_workload), to=self._state.replicas)
                                _st_label_798 += 1
                            else:
                                super()._label('_st_label_798', block=True, timeout=self._state.client_timeout)
                                _st_label_798 -= 1
                        else:
                            if (_st_label_798 != 2):
                                continue
                        if (_st_label_798 != 2):
                            break
                    _st_label_754 += 1
                else:
                    super()._label('_st_label_754', block=True, timeout=self._state.client_timeout)
                    _st_label_754 -= 1

    def execute_pseudorandom_workloads(self, seed, workload_count):
        random.seed(seed)
        op = ['put', 'get', 'slice', 'append']
        opp = ['get', 'slice', 'append']
        workloads = []
        keys = []
        values = []
        maxlength = 0
        for i in range(workload_count):
            temp = ''.join((random.choices(string.ascii_lowercase, k=random.randint(2, 7)) + random.choices(string.ascii_uppercase, k=random.randint(3, 7))))
            values.append(temp)
            maxlength = max(maxlength, len(temp))
        putKeys = []
        put_counts = 0
        if ((workload_count % 3) == 0):
            put_counts = int((workload_count / 3))
        else:
            put_counts = (int((workload_count / 3)) + 1)
        for i in range(int(put_counts)):
            key = ''.join((random.choices(string.ascii_uppercase, k=random.randint(3, 8)) + random.choices(string.ascii_lowercase, k=random.randint(2, 6))))
            value = random.SystemRandom().choices(values)[0]
            workloads.append((((("put('" + key) + "','") + value) + "')"))
            putKeys.append(key)
        other_count = (workload_count - put_counts)
        for i in range(int(other_count)):
            operation = random.SystemRandom().choice(opp)
            key = random.SystemRandom().choices(putKeys)[0]
            value = random.SystemRandom().choices(values)[0]
            if (operation == 'get'):
                workloads.append((("get('" + key) + "')"))
            elif (operation == 'append'):
                workloads.append((((("append('" + key) + "','") + value) + "')"))
            elif (operation == 'slice'):
                start = random.randint(0, maxlength)
                end = random.randint(start, maxlength)
                workloads.append((((((("slice('" + key) + "','") + str(start)) + ':') + str(end)) + "')"))
        for workload in workloads:
            self.retry_for_current_configuration()
            workload = workload.strip().replace("'", '')
            self._state.errorresponsecode = False
            requestIdFinal = ((self._state.clientId + ':') + str(self._state.requestId))
            operation = workload.split('(')[0]
            key_value = workload[(workload.find('(') + 1):workload.find(')')]
            key = key_value.split(',')
            self.execute_workload(operation, key, requestIdFinal, workload)
            self._state.requestId += 1

    def check_validity_of_result_proof(self, result, result_proof):
        result_statements = result_proof
        for i in range(0, len(self._state.replicas)):
            try:
                statement = self._state.utils.verifySignature(result_statements[i], self._state.replicaPublicKeys[i])
                hash = statement.decode('UTF-8').split(';')[(- 1)]
                if (self._state.utils.verifyHash(result, hash.encode('utf-8')) == False):
                    return False
            except:
                return False
        return True

    def _Client_handler_1491(self, result, result_proof, reqId, tail):
        self.output(((((((('Received result [' + result) + '] at client ') + str(self._id)) + ' from tail ') + str(tail)) + ' for requestId = ') + reqId))
        if (self.check_validity_of_result_proof(result, result_proof) == False):
            self.output(((('Proof of Misbehaviour detected at client ' + str(self._id)) + ' because of invalid result proof of request: ') + reqId))
            self.output(('Sending Reconfiguration Request to Olympus from Client: ' + str(self._id)))
            self.send(('Reconfiguration request from client', result, result, result_proof, self._id), to=self._state.olympus)
        elif (self._state.requestToResult[reqId] == result):
            if (not (reqId in self._state.completedRequests)):
                self._state.completedRequests[reqId] = (result, tail)
        else:
            self.output(((('Proof of Misbehaviour detected at client ' + str(self._id)) + ' because of invalid result of request: ') + reqId))
            self.output(('Sending Reconfiguration Request to Olympus from Client: ' + str(self._id)))
            self.send(('Reconfiguration request from client', self._state.requestToResult[reqId], result, result_proof, self._id), to=self._state.olympus)
    _Client_handler_1491._labels = None
    _Client_handler_1491._notlabels = None

    def _Client_handler_1674(self, replicas, head, tail, isValidConfigPresent, replicaPublicKeys, olympus):
        self.output(((((((((('Received configuration -> [ replicas:' + str(replicas)) + ', head:') + str(head)) + ', tail:') + str(tail)) + '] from the olympus at the client ') + str(self._id)) + ' with flag ') + str(isValidConfigPresent)))
        self._state.head = head
        self._state.tail = tail
        self._state.replicas = replicas
        self._state.replicaPublicKeys = replicaPublicKeys
        self._state.isValidConfigPresent = isValidConfigPresent
    _Client_handler_1674._labels = None
    _Client_handler_1674._notlabels = None

    def _Client_handler_1749(self, result, operation_object, result_proof, replica, responseCode, signed_workload, p):
        reqId = operation_object.requestId
        self.output(((((((('Received retried operation response for RequestId [' + reqId) + '] and result [') + str(result)) + '] from the replica ') + str(p)) + ' at the client ') + str(self._id)))
        if (responseCode == 'VALID'):
            if (not (result_proof == None)):
                if (self.check_validity_of_result_proof(result, result_proof) == False):
                    self.output(((('Proof of Misbehaviour detected at client ' + str(self._id)) + ' because of invalid result proof of request: ') + reqId))
                    self.output(('Sending Reconfiguration Request to Olympus from Client: ' + str(self._id)))
                    self.send(('Reconfiguration request from client', result, result, result_proof, self._id), to=self._state.olympus)
                elif (self._state.requestToResult[reqId] == result):
                    if (not (replica in self._state.distinct_replicas)):
                        self._state.distinct_replicas.append(replica)
                    if (len(self._state.distinct_replicas) > (len(self._state.replicas) / 2)):
                        if (not (reqId in self._state.completedRequests)):
                            self.output(('Got Response from Quorum of Replicas for Retransmitted Response for RequestId' + str(reqId)))
                            self._state.completedRequests[reqId] = (result, replica)
                else:
                    self.output(((('Proof of Misbehaviour detected at client ' + str(self._id)) + ' because of invalid result of request: ') + reqId))
                    self.output(('Sending Reconfiguration Request to Olympus from Client: ' + str(self._id)))
                    self.send(('Reconfiguration request from client', self._state.requestToResult[reqId], result, result_proof, self._id), to=self._state.olympus)
        elif (responseCode == 'ERROR'):
            if (self._state.errorresponsecode == False):
                self._state.errorresponsecode = True
                self.retry_for_current_configuration()
                self.send(('Execute Operation Of Client', operation_object, self._id, signed_workload), to=self._state.head)
    _Client_handler_1749._labels = None
    _Client_handler_1749._notlabels = None

    def _Client_handler_1950(self, result, reqId, olympus):
        self.output(((((((('Received result [' + result) + '] at client ') + str(self._id)) + ' from olympus ') + str(olympus)) + ' for requestId = ') + reqId))
        if (not (reqId in self._state.completedRequests)):
            self._state.completedRequests[reqId] = (result, olympus)
    _Client_handler_1950._labels = None
    _Client_handler_1950._notlabels = None
