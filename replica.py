# -*- generated by 1.0.10 -*-
import da
PatternExpr_740 = da.pat.TuplePattern([da.pat.ConstantPattern('Become Active'), da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)])
PatternExpr_749 = da.pat.FreePattern('olympus')
PatternExpr_771 = da.pat.ConstantPattern('Finised Processing')
PatternExpr_775 = da.pat.FreePattern('olympus')
PatternExpr_1704 = da.pat.TuplePattern([da.pat.ConstantPattern('Forward Shuttle To Successor'), da.pat.FreePattern('shuttle'), da.pat.FreePattern('client'), da.pat.FreePattern('signed_workload')])
PatternExpr_1715 = da.pat.BoundPattern('_BoundPattern1719_')
PatternExpr_2032 = da.pat.TuplePattern([da.pat.ConstantPattern('Forward Shuttle to Predecessor'), da.pat.FreePattern('result_shuttle'), da.pat.FreePattern('result'), da.pat.FreePattern('requestId')])
PatternExpr_2043 = da.pat.BoundPattern('_BoundPattern2047_')
PatternExpr_2577 = da.pat.TuplePattern([da.pat.ConstantPattern('Execute Operation Of Client'), da.pat.FreePattern('operation_object'), da.pat.FreePattern('client'), da.pat.FreePattern('signed_workload')])
PatternExpr_2588 = da.pat.FreePattern('p')
PatternExpr_3473 = da.pat.TuplePattern([da.pat.ConstantPattern('forward_checkpoint_shuttle'), da.pat.FreePattern('replica'), da.pat.FreePattern('checkpoint_shuttle')])
PatternExpr_4003 = da.pat.TuplePattern([da.pat.ConstantPattern('completed_checkpoint_shuttle'), da.pat.FreePattern('replica'), da.pat.FreePattern('completed_checkpoint_shuttle')])
PatternExpr_4675 = da.pat.TuplePattern([da.pat.ConstantPattern('Retransmit Request To Replicas'), da.pat.FreePattern('operation_object'), da.pat.FreePattern('client'), da.pat.FreePattern('signed_workload')])
PatternExpr_4686 = da.pat.FreePattern('p')
PatternExpr_4875 = da.pat.TuplePattern([da.pat.ConstantPattern('Retransmit To Head'), da.pat.FreePattern('operation_object'), da.pat.FreePattern('client'), da.pat.FreePattern('signed_workload')])
PatternExpr_4886 = da.pat.FreePattern('p')
PatternExpr_5252 = da.pat.TuplePattern([da.pat.ConstantPattern('Become Active'), da.pat.FreePattern('head'), da.pat.FreePattern('tail'), da.pat.FreePattern('id'), da.pat.FreePattern('replicas')])
PatternExpr_5262 = da.pat.FreePattern('olympus')
PatternExpr_5374 = da.pat.ConstantPattern('Wedge request')
PatternExpr_5378 = da.pat.FreePattern('olympus')
PatternExpr_5788 = da.pat.TuplePattern([da.pat.ConstantPattern('Catch up'), da.pat.FreePattern('operations')])
PatternExpr_5795 = da.pat.FreePattern('olympus')
PatternExpr_6239 = da.pat.ConstantPattern('Get running state')
PatternExpr_6243 = da.pat.FreePattern('olympus')
PatternExpr_6536 = da.pat.ConstantPattern('Kill old replicas')
PatternExpr_6540 = da.pat.FreePattern('olympus')
_config_object = {'channel': {'fifo', 'reliable'}, 'clock': 'lamport'}
import sys
import os
import time
import random
import string
import copy
from datetime import datetime
from utils import Utils, State
from operation import Operation
from datetime import datetime
from orderStatement import OrderStatement
from resultStatement import ResultStatement
from checkpointStatement import CheckpointStatement
from wedgedMessage import WedgedMessage
from shuttle import Shuttle
from checkpointShuttle import CheckpointShuttle
CLIENT = da.import_da('client')
OLYMPUS = da.import_da('olympus')

class Replica(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ReplicaReceivedEvent_0 = []
        self._ReplicaReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_0', PatternExpr_740, sources=[PatternExpr_749], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_1', PatternExpr_771, sources=[PatternExpr_775], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_2', PatternExpr_1704, sources=[PatternExpr_1715], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1703]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_3', PatternExpr_2032, sources=[PatternExpr_2043], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_2031]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_4', PatternExpr_2577, sources=[PatternExpr_2588], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_2576]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_5', PatternExpr_3473, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3472]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_6', PatternExpr_4003, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_4002]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_7', PatternExpr_4675, sources=[PatternExpr_4686], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_4674]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_8', PatternExpr_4875, sources=[PatternExpr_4886], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_4874]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_9', PatternExpr_5252, sources=[PatternExpr_5262], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_5251]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_10', PatternExpr_5374, sources=[PatternExpr_5378], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_5373]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_11', PatternExpr_5788, sources=[PatternExpr_5795], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_5787]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_12', PatternExpr_6239, sources=[PatternExpr_6243], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_6238]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_13', PatternExpr_6536, sources=[PatternExpr_6540], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_6535])])

    def setup(self, olympus, replicaPublicKeys, replicaPrivateKey, olympusPublicKey, state, head_timeout, nonhead_timeout, failures, checkpt_interval, runningstate, clientPublicKeys, **rest_6556):
        super().setup(olympus=olympus, replicaPublicKeys=replicaPublicKeys, replicaPrivateKey=replicaPrivateKey, olympusPublicKey=olympusPublicKey, state=state, head_timeout=head_timeout, nonhead_timeout=nonhead_timeout, failures=failures, checkpt_interval=checkpt_interval, runningstate=runningstate, clientPublicKeys=clientPublicKeys, **rest_6556)
        self._state.olympus = olympus
        self._state.replicaPublicKeys = replicaPublicKeys
        self._state.replicaPrivateKey = replicaPrivateKey
        self._state.olympusPublicKey = olympusPublicKey
        self._state.state = state
        self._state.head_timeout = head_timeout
        self._state.nonhead_timeout = nonhead_timeout
        self._state.failures = failures
        self._state.checkpt_interval = checkpt_interval
        self._state.runningstate = runningstate
        self._state.clientPublicKeys = clientPublicKeys
        self._state.state = self._state.state
        self._state.olympus = self._state.olympus
        self._state.replicaPublicKeys = self._state.replicaPublicKeys
        self._state.olympusPublicKey = self._state.olympusPublicKey
        self._state.replicaPrivateKey = self._state.replicaPrivateKey
        self._state.clientPublicKeys = self._state.clientPublicKeys
        self._state.isHeadFlag = False
        self._state.isTailFlag = False
        self._state.predecessorReplica = None
        self._state.successorReplica = None
        self._state.Id = None
        self._state.head = None
        self._state.tail = None
        self._state.nonhead_timeout = self._state.nonhead_timeout
        self._state.head_timeout = self._state.head_timeout
        self._state.runningstate = self._state.runningstate
        self._state.requestIdToForwardedRequests = {}
        self._state.requestIdToResultShuttle = {}
        self._state.slotNo = (- 1)
        self._state.failures = self._state.failures
        self._state.inProcessRequestIds = {}
        self._state.historyoforderproofs = []
        self._state.historyofcheckpointproofs = []
        self._state.utils = Utils()
        self._state.checkpt_interval = self._state.checkpt_interval
        self._state.runningstateForCheckpoint = {}
        self._state.lastresultstatement = {}
        self._state.directlyfromclient = {}
        self._state.forwardedmessageforclient = {}
        self._state.shuttleforclient = {}
        self._state.resultshuttleforclient = {}
        self._state.failureInjections = {}
        self._state.checkpoints = (- 1)
        self._state.completed_checkpoints = (- 1)
        self._state.catch_up = (- 1)
        self._state.wedge_request = (- 1)
        self._state.get_running_state = (- 1)
        failurekey = (('new_configuration(' + str(0)) + ')')
        if (failurekey in self._state.failures):
            try:
                self._state.failureInjections[self._state.failures[failurekey]] += 1
            except KeyError:
                self._state.failureInjections[self._state.failures[failurekey]] = 1
        if any((key.startswith('sleep') for key in self._state.failureInjections)):
            sleep = [key for key in self._state.failureInjections.keys() if ('sleep' in key)][0]
            self.output(('Sleep Time Failure Triggered at replica: ' + str(self._id)))
            self._state.failureInjections[sleep] -= 1
            if (self._state.failureInjections[sleep] == 0):
                self._state.failureInjections.pop(sleep)
            sleeptime = sleep[(sleep.find('(') + 1):sleep.find(')')]
            time.sleep(int(sleeptime))
        if ('crash()' in self._state.failureInjections):
            self.output(('Killing Replica Failure Triggered at replica: ' + str(self._id)))
            os._exit((- 1))
            return
        if ('drop()' in self._state.failureInjections):
            self.output((('Drop Failure Triggered at replica: ' + str(self._id)) + ' during sending shuttle forward'))
            self._state.failureInjections['drop()'] -= 1
            if (self._state.failureInjections['drop()'] == 0):
                self._state.failureInjections.pop('drop()')
            return
        if ('increment_slot()' in self._state.failureInjections):
            self.output(('Increment Slot Failure Triggered at replica: ' + str(self._id)))
            self._state.failureInjections['increment_slot()'] -= 1
            if (self._state.failureInjections['increment_slot()'] == 0):
                self._state.failureInjections.pop('increment_slot()')
            if self._state.isHeadFlag:
                self._state.slotNo = (self._state.slotNo + 1)
        if ('extra_op()' in self._state.failureInjections):
            self.output(('Extra Operation Failure Triggered at replica: ' + str(self._id)))
            self._state.failureInjections['extra_op()'] -= 1
            if (self._state.failureInjections['extra_op()'] == 0):
                self._state.failureInjections.pop('extra_op()')
            self.execute_operation('put', 'a', 'a')

    def run(self):
        self.output((('********Starting Replica' + str(self._id)) + '*****'))
        super()._label('yieldInitializeHistory', block=False)
        olympus = None

        def ExistentialOpExpr_738():
            nonlocal olympus
            for (_, (_, _, self._state.olympus), (_ConstantPattern759_, _, _, _, _)) in self._ReplicaReceivedEvent_0:
                if (_ConstantPattern759_ == 'Become Active'):
                    if True:
                        return True
            return False
        _st_label_737 = 0
        while (_st_label_737 == 0):
            _st_label_737 += 1
            if ExistentialOpExpr_738():
                _st_label_737 += 1
            else:
                super()._label('yieldInitializeHistory', block=True)
                _st_label_737 -= 1
        super()._label('_st_label_768', block=False)
        olympus = None

        def ExistentialOpExpr_769():
            nonlocal olympus
            for (_, (_, _, self._state.olympus), _ConstantPattern784_) in self._ReplicaReceivedEvent_1:
                if (_ConstantPattern784_ == 'Finised Processing'):
                    if True:
                        return True
            return False
        _st_label_768 = 0
        while (_st_label_768 == 0):
            _st_label_768 += 1
            if ExistentialOpExpr_769():
                _st_label_768 += 1
            else:
                super()._label('_st_label_768', block=True)
                _st_label_768 -= 1

    def check_validity_of_order_proof(self, shuttle):
        order_statements = shuttle.order_proof
        operation_object = shuttle.operation
        for i in range(0, len(order_statements)):
            try:
                order_statement = self._state.utils.verifySignature(order_statements[i], self._state.replicaPublicKeys[i]).decode('UTF-8')
                if (not (str(order_statement) == str(operation_object))):
                    return False
            except:
                return False
        return True

    def check_validity_of_result_proof(self, shuttle, result):
        result_statements = shuttle.result_proof
        for i in range(0, len(result_statements)):
            try:
                statement = self._state.utils.verifySignature(result_statements[i], self._state.replicaPublicKeys[i])
                hash = statement.decode('UTF-8').split(';')[(- 1)]
                if (self._state.utils.verifyHash(result, hash.encode('utf-8')) == False):
                    return False
            except:
                return False
        return True

    def execute_operation(self, operation, key, value):
        output = 'None'
        if (operation == 'put'):
            self._state.runningstate[key] = value
            output = 'OK'
        elif (operation == 'get'):
            if (key in self._state.runningstate):
                output = self._state.runningstate[key]
            else:
                output = ''
        elif (operation == 'slice'):
            if (key in self._state.runningstate):
                (i, j) = value.split(':')
                val = self._state.runningstate[key]
                if ((int(j) < len(val)) and (int(i) >= 0)):
                    self._state.runningstate[key] = val[int(i):int(j)]
                    output = 'OK'
                else:
                    output = 'Fail'
        elif (operation == 'append'):
            if (key in self._state.runningstate):
                self._state.runningstate[key] += str(value)
                output = 'OK'
            else:
                output = 'Fail'
        return output

    def execute_operation_of_client(self, client, shuttle, signed_workload):
        operation_object = copy.deepcopy(shuttle.operation)
        requestId = operation_object.requestId
        order_proof = shuttle.order_proof
        result_proof = shuttle.result_proof
        if (self._state.state == State.ACTIVE.value):
            clientId = requestId.split(':')[0][1:]
            decoded_workload = ''
            verification = True
            try:
                decoded_workload = self._state.utils.verifySignature(signed_workload, self._state.clientPublicKeys[int(clientId)]).decode('UTF-8')
            except Exception:
                verification = False
            actual_workload = Operation().getWorkload(operation_object)
            if ((not (str(decoded_workload) == str(actual_workload))) or (verification == False)):
                self.output(((((('Proof of Misbehaviour detected at replica ' + str(self._id)) + ' due to invalid signature of client') + str(client)) + 'for requestid: ') + requestId))
                self.output(('Sending Reconfiguration Request to Olympus from Replica ' + str(self._id)))
                self.send(('Reconfiguration request from replica', self._id), to=self._state.olympus)
                return
            if ((self._state.isHeadFlag == False) and (not (operation_object.slotNo == (self._state.slotNo + 1)))):
                self.output(((('Proof of Misbehaviour detected at replica ' + str(self._id)) + ' due to holes at requestid: ') + requestId))
                self.output(((('Expected slot No: ' + str((self._state.slotNo + 1))) + ' , Actual slotNo recieved : ') + str(operation_object.slotNo)))
                self.output(('Sending Reconfiguration Request to Olympus from Replica ' + str(self._id)))
                self.send(('Reconfiguration request from replica', self._id), to=self._state.olympus)
                return
            if self.check_validity_of_order_proof(shuttle):
                self.output(((((('Executing operation: ' + operation_object.command) + ' with requestId ') + operation_object.requestId) + ' at replica ') + str(self._id)))
                self._state.slotNo = operation_object.slotNo
                self._state.inProcessRequestIds[requestId] = 1
                msgNo = int(requestId.split(':')[1])
                cid = requestId.split(':')[0]
                if ('change_operation()' in self._state.failureInjections):
                    self.output(('Change Operation Failure Triggered at replica: ' + str(self._id)))
                    operation_object.command = 'get'
                    operation_object.key = 'x'
                    operation_object.value = ''
                    self._state.failureInjections['change_operation()'] -= 1
                    if (self._state.failureInjections['change_operation()'] == 0):
                        self._state.failureInjections.pop('change_operation()')
                order_statement = OrderStatement()
                order_statement.operation = operation_object
                signed_order_statement = self._state.utils.getSignedStatement(self._state.replicaPrivateKey, str(order_statement))
                if ('invalid_order_sig()' in self._state.failureInjections):
                    self.output(('Invalid Order Statement Signature Failure Triggered at replica: ' + str(self._id)))
                    signed_order_statement = self._state.utils.getInvalidSignedStatement(signed_order_statement)
                    self._state.failureInjections['invalid_order_sig()'] -= 1
                    if (self._state.failureInjections['invalid_order_sig()'] == 0):
                        self._state.failureInjections.pop('invalid_order_sig()')
                order_proof.append(signed_order_statement)
                key = operation_object.key
                value = operation_object.value
                operation = operation_object.command
                output = self.execute_operation(operation, key, value)
                if ((self._state.slotNo % self._state.checkpt_interval) == (self._state.checkpt_interval - 1)):
                    self._state.runningstateForCheckpoint = self._state.runningstate
                if ('change_result()' in self._state.failureInjections):
                    self.output(('Change Result Failure Triggered at replica: ' + str(self._id)))
                    output = 'OK'
                    self._state.failureInjections['change_result()'] -= 1
                    if (self._state.failureInjections['change_result()'] == 0):
                        self._state.failureInjections.pop('change_result()')
                result_hash = self._state.utils.getHash(output)
                result_statement = ResultStatement()
                result_statement.operation = operation_object
                result_statement.result = result_hash
                signed_result_statement = self._state.utils.getSignedStatement(self._state.replicaPrivateKey, str(result_statement))
                if ('invalid_result_sig()' in self._state.failureInjections):
                    self.output(('Invalid Result Statement Signature Failure Triggered at replica: ' + str(self._id)))
                    signed_result_statement = self._state.utils.getInvalidSignedStatement(signed_result_statement)
                    self._state.failureInjections['invalid_result_sig()'] -= 1
                    if (self._state.failureInjections['invalid_result_sig()'] == 0):
                        self._state.failureInjections.pop('invalid_result_sig()')
                result_proof.append(signed_result_statement)
                if ('drop_result_stmt()' in self._state.failureInjections):
                    self.output(('Omit Result Statement Failure Triggered at replica: ' + str(self._id)))
                    shuttle.result_proof = shuttle.result_proof[1:]
                    self._state.failureInjections['drop_result_stmt()'] -= 1
                    if (self._state.failureInjections['drop_result_stmt()'] == 0):
                        self._state.failureInjections.pop('drop_result_stmt()')
                self._state.historyoforderproofs.append(order_proof)
                self._state.lastresultstatement[cid] = (output, signed_result_statement, operation_object)
                if (self._state.isTailFlag == True):
                    result_shuttle = Shuttle()
                    result_shuttle.operation = operation_object
                    result_statement.result = result_hash
                    result_shuttle.result_proof = result_proof
                    self._state.inProcessRequestIds[requestId] = 0
                    self._state.requestIdToResultShuttle[requestId] = (output, result_shuttle)
                    self.send(('Forward Result to Client', output, result_shuttle.result_proof, requestId), to=client)
                    self.send(('Forward Shuttle to Predecessor', result_shuttle, output, requestId), to=self._state.predecessorReplica)
                else:
                    self.send(('Forward Shuttle To Successor', shuttle, client, signed_workload), to=self._state.successorReplica)
            else:
                self.output(((('Proof of Misbehaviour detected at replica ' + str(self._id)) + ' due to invalid order proof of request: ') + requestId))
                self.output(('Sending Reconfiguration Request to Olympus from Replica ' + str(self._id)))
                self.send(('Reconfiguration request from replica', self._id), to=self._state.olympus)
        else:
            self.output((('Replica ' + str(self._id)) + ' is immutable now'))

    def initiate_checkpoint_periodically(self):
        if (self._state.state == State.ACTIVE.value):
            self._state.checkpoints += 1
            failurekey = (('checkpoint(' + str(self._state.checkpoints)) + ')')
            if (failurekey in self._state.failures):
                try:
                    self._state.failureInjections[self._state.failures[failurekey]] += 1
                except KeyError:
                    self._state.failureInjections[self._state.failures[failurekey]] = 1
            if any((key.startswith('sleep') for key in self._state.failureInjections)):
                sleep = [key for key in self._state.failureInjections.keys() if ('sleep' in key)][0]
                self.output(('Sleep Time Failure Triggered at replica: ' + str(self._id)))
                self._state.failureInjections[sleep] -= 1
                if (self._state.failureInjections[sleep] == 0):
                    self._state.failureInjections.pop(sleep)
                sleeptime = sleep[(sleep.find('(') + 1):sleep.find(')')]
                time.sleep(int(sleeptime))
            if ('crash()' in self._state.failureInjections):
                self.output(('Killing Replica Failure Triggered at replica: ' + str(self._id)))
                os._exit((- 1))
                return
            if ('drop()' in self._state.failureInjections):
                self.output((('Drop Failure Triggered at replica: ' + str(self._id)) + ' during sending the checkpoint shuttle forward'))
                self._state.failureInjections['drop()'] -= 1
                if (self._state.failureInjections['drop()'] == 0):
                    self._state.failureInjections.pop('drop()')
                return
            if ('increment_slot()' in self._state.failureInjections):
                self.output(('Increment Slot Failure Triggered at replica: ' + str(self._id)))
                self._state.failureInjections['increment_slot()'] -= 1
                if (self._state.failureInjections['increment_slot()'] == 0):
                    self._state.failureInjections.pop('increment_slot()')
                if self._state.isHeadFlag:
                    self._state.slotNo = (self._state.slotNo + 1)
            if ('extra_op()' in self._state.failureInjections):
                self.output(('Extra Operation Failure Triggered at replica: ' + str(self._id)))
                self._state.failureInjections['extra_op()'] -= 1
                if (self._state.failureInjections['extra_op()'] == 0):
                    self._state.failureInjections.pop('extra_op()')
                self.execute_operation('put', 'a', 'a')
            if ((not (self._state.slotNo == 0)) and ((self._state.slotNo % self._state.checkpt_interval) == 0)):
                if (self._state.isHeadFlag == True):
                    self.output(((('Initializing checkpoint upto slotNo: ' + str((self._state.slotNo - 1))) + ' on replica: ') + str(self._id)))
                else:
                    self.output(((('Initializing checkpoint upto slotNo: ' + str(self._state.slotNo)) + ' on replica: ') + str(self._id)))
                checkpoint_statement = CheckpointStatement()
                checkpoint_statement.checkpoint_slot = self._state.slotNo
                checkpoint_statement.running_state = self._state.utils.getHash(str(self._state.runningstateForCheckpoint))
                signed_checkpoint_statement = self._state.utils.getSignedStatement(self._state.replicaPrivateKey, str(checkpoint_statement))
                checkpoint_proof = []
                checkpoint_proof.append(signed_checkpoint_statement)
                checkpoint_shuttle = CheckpointShuttle()
                checkpoint_shuttle.checkpoint_slot = checkpoint_statement.checkpoint_slot
                checkpoint_shuttle.checkpoint_proof = checkpoint_proof
                self.output(((('Sending checkpoint Shuttle to Successor Replica: ' + str(self._state.successorReplica)) + ' from ') + str(self._id)))
                self.send(('forward_checkpoint_shuttle', self._id, checkpoint_shuttle), to=self._state.successorReplica)
        else:
            self.output((('No checkpointing as Replica ' + str(self._id)) + ' is immutable now'))

    def check_validity_of_checkpoint_proof(self, checkpoint_proof):
        checkpoint_set = set()
        if (len(checkpoint_proof) < (int((len(self._state.replicaPublicKeys) / 2)) + 1)):
            return False
        for i in range(0, len(checkpoint_proof)):
            verification = True
            checkpoint_statement = ''
            try:
                checkpoint_statement = self._state.utils.verifySignature(checkpoint_proof[i], self._state.replicaPublicKeys[i]).decode('UTF-8')
            except Exception:
                verification = False
            if (verification == True):
                checkpoint_set.add(checkpoint_statement)
        if (len(checkpoint_set) > (int((len(self._state.replicaPublicKeys) / 2)) + 1)):
            return False
        return True

    def execute_retransmitted_request_at_head(self, operation_object, client, signed_workload):
        requestId = operation_object.requestId
        if ((requestId in self._state.inProcessRequestIds) and (self._state.inProcessRequestIds[requestId] == 0)):
            (result, shuttle) = self._state.requestIdToResultShuttle[requestId]
            self.send(('Retransmitted Response', result, operation_object, shuttle.result_proof, self._id, 'VALID', signed_workload), to=client)
        elif ((requestId in self._state.inProcessRequestIds) and (self._state.inProcessRequestIds[requestId] == 1)):
            super()._label('_st_label_4519', block=False)
            _st_label_4519 = 0
            self._timer_start()
            while (_st_label_4519 == 0):
                _st_label_4519 += 1
                if ((requestId in self._state.inProcessRequestIds) and (self._state.inProcessRequestIds[requestId] == 0)):
                    (result, shuttle) = self._state.requestIdToResultShuttle[requestId]
                    self.send(('Retransmitted Response', result, operation_object, shuttle.result_proof, self._id, 'VALID', signed_workload), to=client)
                    _st_label_4519 += 1
                elif self._timer_expired:
                    self.output(((('Timeout detected at head ' + str(self._id)) + ' for requestId: ') + requestId))
                    self.output(('Sending Reconfiguration Request to Olympus from Head ' + str(self._id)))
                    self.send(('Reconfiguration request from replica', self._id), to=self._state.olympus)
                    _st_label_4519 += 1
                else:
                    super()._label('_st_label_4519', block=True, timeout=self._state.head_timeout)
                    _st_label_4519 -= 1
        elif (not (requestId in self._state.inProcessRequestIds)):
            self._state.slotNo = (self._state.slotNo + 1)
            operation_object.slotNo = self._state.slotNo
            shuttle = Shuttle()
            shuttle.operation = operation_object
            self.execute_operation_of_client(client, shuttle, signed_workload)
            super()._label('_st_label_4614', block=False)
            _st_label_4614 = 0
            self._timer_start()
            while (_st_label_4614 == 0):
                _st_label_4614 += 1
                if ((requestId in self._state.inProcessRequestIds) and (self._state.inProcessRequestIds[requestId] == 0)):
                    (result, shuttle) = self._state.requestIdToResultShuttle[requestId]
                    self.send(('Retransmitted Response', result, operation_object, shuttle.result_proof, self._id, 'VALID', signed_workload), to=client)
                    _st_label_4614 += 1
                elif self._timer_expired:
                    self.output(((('Timeout detected at head ' + str(self._id)) + ' for requestId: ') + requestId))
                    self.output(('Sending Reconfiguration Request to Olympus from Head ' + str(self._id)))
                    self.send(('Reconfiguration request from replica', self._id), to=self._state.olympus)
                    _st_label_4614 += 1
                else:
                    super()._label('_st_label_4614', block=True, timeout=self._state.head_timeout)
                    _st_label_4614 -= 1

    def _Replica_handler_1703(self, shuttle, client, signed_workload):
        operation_object = copy.deepcopy(shuttle.operation)
        self.output(((((((('Received shuttle from the previous replica -> ' + str(self._state.predecessorReplica)) + ' on replica ') + str(self._id)) + ' for operation: ') + operation_object.command) + ' and request: ') + operation_object.requestId))
        if (self._state.state == State.ACTIVE.value):
            cid = operation_object.requestId.split(':')[0]
            try:
                self._state.shuttleforclient[cid] += 1
            except KeyError:
                self._state.shuttleforclient[cid] = 0
            m = self._state.shuttleforclient[cid]
            failurekey = (((('shuttle(' + str(cid[1:])) + ',') + str(m)) + ')')
            if (failurekey in self._state.failures):
                try:
                    self._state.failureInjections[self._state.failures[failurekey]] += 1
                except KeyError:
                    self._state.failureInjections[self._state.failures[failurekey]] = 1
            if any((key.startswith('sleep') for key in self._state.failureInjections)):
                sleep = [key for key in self._state.failureInjections.keys() if ('sleep' in key)][0]
                self.output(('Sleep Time Failure Triggered at replica: ' + str(self._id)))
                self._state.failureInjections[sleep] -= 1
                if (self._state.failureInjections[sleep] == 0):
                    self._state.failureInjections.pop(sleep)
                sleeptime = sleep[(sleep.find('(') + 1):sleep.find(')')]
                time.sleep(int(sleeptime))
            if ('crash()' in self._state.failureInjections):
                self.output(('Killing Replica Failure Triggered at replica: ' + str(self._id)))
                os._exit((- 1))
                return
            if ('drop()' in self._state.failureInjections):
                self.output((('Drop Failure Triggered at replica: ' + str(self._id)) + ' during sending shuttle forward'))
                self._state.failureInjections['drop()'] -= 1
                if (self._state.failureInjections['drop()'] == 0):
                    self._state.failureInjections.pop('drop()')
                return
            if ('extra_op()' in self._state.failureInjections):
                self.output(('Extra Operation Failure Triggered at replica: ' + str(self._id)))
                self._state.failureInjections['extra_op()'] -= 1
                if (self._state.failureInjections['extra_op()'] == 0):
                    self._state.failureInjections.pop('extra_op()')
                self.execute_operation('put', 'a', 'a')
            self.execute_operation_of_client(client, shuttle, signed_workload)
    _Replica_handler_1703._labels = None
    _Replica_handler_1703._notlabels = None

    def _Replica_handler_2031(self, result_shuttle, result, requestId):
        self.output(((((('Received result shuttle from the successor replica -> ' + str(self._state.successorReplica)) + ' on replica ') + str(self._id)) + ' for request: ') + requestId))
        if (self._state.state == State.ACTIVE.value):
            cid = requestId.split(':')[0]
            try:
                self._state.resultshuttleforclient[cid] += 1
            except KeyError:
                self._state.resultshuttleforclient[cid] = 0
            m = self._state.resultshuttleforclient[cid]
            failurekey = (((('result_shuttle(' + str(cid[1:])) + ',') + str(m)) + ')')
            if (failurekey in self._state.failures):
                try:
                    self._state.failureInjections[self._state.failures[failurekey]] += 1
                except KeyError:
                    self._state.failureInjections[self._state.failures[failurekey]] = 1
            if any((key.startswith('sleep') for key in self._state.failureInjections)):
                sleep = [key for key in self._state.failureInjections.keys() if ('sleep' in key)][0]
                self.output(('Sleep Time Failure Triggered at replica: ' + str(self._id)))
                self._state.failureInjections[sleep] -= 1
                if (self._state.failureInjections[sleep] == 0):
                    self._state.failureInjections.pop(sleep)
                sleeptime = sleep[(sleep.find('(') + 1):sleep.find(')')]
                time.sleep(int(sleeptime))
            if ('crash()' in self._state.failureInjections):
                self.output(('Killing Replica Failure Triggered at replica: ' + str(self._id)))
                os._exit((- 1))
                return
            if ('drop()' in self._state.failureInjections):
                self.output((('Drop Failure Triggered at replica: ' + str(self._id)) + ' during sending result shuttle backward'))
                self._state.failureInjections['drop()'] -= 1
                if (self._state.failureInjections['drop()'] == 0):
                    self._state.failureInjections.pop('drop()')
                return
            if ('increment_slot()' in self._state.failureInjections):
                self.output(('Increment Slot Failure Triggered at replica: ' + str(self._id)))
                self._state.failureInjections['increment_slot()'] -= 1
                if (self._state.failureInjections['increment_slot()'] == 0):
                    self._state.failureInjections.pop('increment_slot()')
                if self._state.isHeadFlag:
                    self._state.slotNo = (self._state.slotNo + 1)
            if ('extra_op()' in self._state.failureInjections):
                self.output(('Extra Operation Failure Triggered at replica: ' + str(self._id)))
                self._state.failureInjections['extra_op()'] -= 1
                if (self._state.failureInjections['extra_op()'] == 0):
                    self._state.failureInjections.pop('extra_op()')
                self.execute_operation('put', 'a', 'a')
            if self.check_validity_of_result_proof(result_shuttle, result):
                self._state.inProcessRequestIds[requestId] = 0
                self._state.requestIdToResultShuttle[requestId] = (result, result_shuttle)
                if ('change_result()' in self._state.failureInjections):
                    self.output(('Change Result Statement Failure Triggered at replica: ' + str(self._id)))
                    output = 'OK'
                    result_hash = self._state.utils.getHash(output)
                    result_statement = ResultStatement()
                    result_statement.result = result_hash
                    signed_result_statement = self._state.utils.getSignedStatement(self._state.replicaPrivateKey, str(result_statement))
                    result_shuttle.result_proof[int(self._state.Id[1:])] = signed_result_statement
                    result_shuttle.result = result_hash
                    self._state.failureInjections['change_result()'] -= 1
                    if (self._state.failureInjections['change_result()'] == 0):
                        self._state.failureInjections.pop('change_result()')
                if ('drop_result_stmt()' in self._state.failureInjections):
                    self.output(('Omit Result Statement Failure Triggered at replica: ' + str(self._id)))
                    result_shuttle.result_proof = result_shuttle.result_proof[1:]
                    self._state.failureInjections['drop_result_stmt()'] -= 1
                    if (self._state.failureInjections['drop_result_stmt()'] == 0):
                        self._state.failureInjections.pop('drop_result_stmt()')
                if (not (self._state.isHeadFlag == True)):
                    self.send(('Forward Shuttle to Predecessor', result_shuttle, result, requestId), to=self._state.predecessorReplica)
            else:
                self.output(((('Proof of Misbehaviour detected at replica ' + str(self._id)) + ' due to invalid result proof of request: ') + requestId))
                self.output(('Sending Reconfiguration Request to Olympus from Replica ' + str(self._id)))
                self.send(('Reconfiguration request from replica', self._id), to=self._state.olympus)
        else:
            self.output((('Replica ' + str(self._id)) + ' is immutable now'))
    _Replica_handler_2031._labels = None
    _Replica_handler_2031._notlabels = None

    def _Replica_handler_2576(self, operation_object, client, signed_workload, p):
        if (self._state.state == State.ACTIVE.value):
            self.output(((((('Received operation_object ' + str(operation_object)) + ' on head: ') + str(self._id)) + ' for requestId: ') + operation_object.requestId))
            cid = operation_object.requestId.split(':')[0]
            try:
                self._state.directlyfromclient[cid] += 1
            except KeyError:
                self._state.directlyfromclient[cid] = 0
            m = self._state.directlyfromclient[cid]
            failurekey = (((('client_request(' + str(cid[1:])) + ',') + str(m)) + ')')
            if (failurekey in self._state.failures):
                try:
                    self._state.failureInjections[self._state.failures[failurekey]] += 1
                except KeyError:
                    self._state.failureInjections[self._state.failures[failurekey]] = 1
            if any((key.startswith('sleep') for key in self._state.failureInjections)):
                sleep = [key for key in self._state.failureInjections.keys() if ('sleep' in key)][0]
                self.output(('Sleep Time Failure Triggered at replica: ' + str(self._id)))
                self._state.failureInjections[sleep] -= 1
                if (self._state.failureInjections[sleep] == 0):
                    self._state.failureInjections.pop(sleep)
                sleeptime = sleep[(sleep.find('(') + 1):sleep.find(')')]
                time.sleep(int(sleeptime))
            if ('crash()' in self._state.failureInjections):
                self.output(('Killing Replica Failure Triggered at replica: ' + str(self._id)))
                os._exit((- 1))
                return
            if ('drop()' in self._state.failureInjections):
                self.output((('Drop Failure Triggered at replica: ' + str(self._id)) + ' when receiving operation from client'))
                self._state.failureInjections['drop()'] -= 1
                if (self._state.failureInjections['drop()'] == 0):
                    self._state.failureInjections.pop('drop()')
                return
            if ('increment_slot()' in self._state.failureInjections):
                self.output(('Increment Slot Failure Triggered at replica: ' + str(self._id)))
                self._state.failureInjections['increment_slot()'] -= 1
                if (self._state.failureInjections['increment_slot()'] == 0):
                    self._state.failureInjections.pop('increment_slot()')
                if self._state.isHeadFlag:
                    self._state.slotNo = (self._state.slotNo + 1)
            if ('extra_op()' in self._state.failureInjections):
                self.output(('Extra Operation Failure Triggered at replica: ' + str(self._id)))
                self._state.failureInjections['extra_op()'] -= 1
                if (self._state.failureInjections['extra_op()'] == 0):
                    self._state.failureInjections.pop('extra_op()')
                self.execute_operation('put', 'a', 'a')
            self._state.slotNo = (self._state.slotNo + 1)
            operation_object.slotNo = self._state.slotNo
            shuttle = Shuttle()
            shuttle.operation = operation_object
            self.execute_operation_of_client(client, shuttle, signed_workload)
            self.initiate_checkpoint_periodically()
    _Replica_handler_2576._labels = None
    _Replica_handler_2576._notlabels = None

    def _Replica_handler_3472(self, replica, checkpoint_shuttle):
        self.output(((('Received Checkpoint shuttle at replica: ' + str(self._id)) + ' from replica: ') + str(replica)))
        if (self._state.state == State.ACTIVE.value):
            self._state.checkpoints += 1
            failurekey = (('checkpoint(' + str(self._state.checkpoints)) + ')')
            if (failurekey in self._state.failures):
                try:
                    self._state.failureInjections[self._state.failures[failurekey]] += 1
                except KeyError:
                    self._state.failureInjections[self._state.failures[failurekey]] = 1
            if any((key.startswith('sleep') for key in self._state.failureInjections)):
                sleep = [key for key in self._state.failureInjections.keys() if ('sleep' in key)][0]
                self.output(('Sleep Time Failure Triggered at replica: ' + str(self._id)))
                self._state.failureInjections[sleep] -= 1
                if (self._state.failureInjections[sleep] == 0):
                    self._state.failureInjections.pop(sleep)
                sleeptime = sleep[(sleep.find('(') + 1):sleep.find(')')]
                time.sleep(int(sleeptime))
            if ('crash()' in self._state.failureInjections):
                self.output(('Killing Replica Failure Triggered at replica: ' + str(self._id)))
                os._exit((- 1))
                return
            if ('drop()' in self._state.failureInjections):
                self.output((('Drop Failure Triggered at replica: ' + str(self._id)) + ' during sending the checkpoint shuttle forward'))
                self._state.failureInjections['drop()'] -= 1
                if (self._state.failureInjections['drop()'] == 0):
                    self._state.failureInjections.pop('drop()')
                return
            if ('increment_slot()' in self._state.failureInjections):
                self.output(('Increment Slot Failure Triggered at replica: ' + str(self._id)))
                self._state.failureInjections['increment_slot()'] -= 1
                if (self._state.failureInjections['increment_slot()'] == 0):
                    self._state.failureInjections.pop('increment_slot()')
                if self._state.isHeadFlag:
                    self._state.slotNo = (self._state.slotNo + 1)
            if ('extra_op()' in self._state.failureInjections):
                self.output(('Extra Operation Failure Triggered at replica: ' + str(self._id)))
                self._state.failureInjections['extra_op()'] -= 1
                if (self._state.failureInjections['extra_op()'] == 0):
                    self._state.failureInjections.pop('extra_op()')
                self.execute_operation('put', 'a', 'a')
            if True:
                self.output(('Checkpoint shuttle verified at replica: ' + str(self._id)))
                checkpoint_statement = CheckpointStatement()
                checkpoint_statement.checkpoint_slot = checkpoint_shuttle.checkpoint_slot
                checkpoint_statement.running_state = self._state.utils.getHash(str(self._state.runningstateForCheckpoint))
                signed_checkpoint_statement = self._state.utils.getSignedStatement(self._state.replicaPrivateKey, str(checkpoint_statement))
                if (self._state.isTailFlag == True):
                    checkpoint_proof = checkpoint_shuttle.checkpoint_proof
                    checkpoint_proof.append(signed_checkpoint_statement)
                    self.output(('Checkpoint proof completed at Replica: ' + str(self._id)))
                    completed_checkpoint_shuttle = CheckpointShuttle()
                    completed_checkpoint_shuttle.checkpoint_proof = checkpoint_proof
                    if ('drop_checkpt_stmts()' in self._state.failureInjections):
                        self.output(('Drop Checkpoint Operation Failure Triggered at replica: ' + str(self._id)))
                        self._state.failureInjections['drop_checkpt_stmts()'] -= 1
                        if (self._state.failureInjections['drop_checkpt_stmts()'] == 0):
                            self._state.failureInjections.pop('drop_checkpt_stmts()')
                        completed_checkpoint_shuttle.checkpoint_proof = completed_checkpoint_shuttle.checkpoint_proof[(int((len(self._state.replicaPublicKeys) / 2)) + 2):]
                    completed_checkpoint_shuttle.checkpoint_slot = checkpoint_shuttle.checkpoint_slot
                    self.output(((('Truncating history for replica: ' + str(self._id)) + ' upto Slot:') + str((completed_checkpoint_shuttle.checkpoint_slot - 1))))
                    self._state.historyoforderproofs = self._state.historyoforderproofs[self._state.checkpt_interval:]
                    self._state.historyofcheckpointproofs.append(checkpoint_proof)
                    self.output(((('Sending Completed Checkpoint Shuttle backward to Replica: ' + str(self._state.predecessorReplica)) + ' from replica: ') + str(self._id)))
                    self.send(('completed_checkpoint_shuttle', self._id, completed_checkpoint_shuttle), to=self._state.predecessorReplica)
                else:
                    checkpoint_proof = checkpoint_shuttle.checkpoint_proof
                    checkpoint_proof.append(signed_checkpoint_statement)
                    self.output(((('Sending checkpoint Shuttle to Successor Replica: ' + str(self._state.successorReplica)) + ' from ') + str(self._id)))
                    self.send(('forward_checkpoint_shuttle', self._id, checkpoint_shuttle), to=self._state.successorReplica)
        else:
            self.output((('No forwarding of checkpointing as Replica ' + str(self._id)) + ' is immutable now'))
    _Replica_handler_3472._labels = None
    _Replica_handler_3472._notlabels = None

    def _Replica_handler_4002(self, replica, completed_checkpoint_shuttle):
        self.output(((('Received Completed Checkpoint shuttle at replica: ' + str(self._id)) + ' from replica: ') + str(replica)))
        if (self._state.state == State.ACTIVE.value):
            self._state.completed_checkpoints += 1
            failurekey = (('completed_checkpoint(' + str(self._state.completed_checkpoints)) + ')')
            if (failurekey in self._state.failures):
                try:
                    self._state.failureInjections[self._state.failures[failurekey]] += 1
                except KeyError:
                    self._state.failureInjections[self._state.failures[failurekey]] = 1
            if any((key.startswith('sleep') for key in self._state.failureInjections)):
                sleep = [key for key in self._state.failureInjections.keys() if ('sleep' in key)][0]
                self.output(('Sleep Time Failure Triggered at replica: ' + str(self._id)))
                self._state.failureInjections[sleep] -= 1
                if (self._state.failureInjections[sleep] == 0):
                    self._state.failureInjections.pop(sleep)
                sleeptime = sleep[(sleep.find('(') + 1):sleep.find(')')]
                time.sleep(int(sleeptime))
            if ('crash()' in self._state.failureInjections):
                self.output(('Killing Replica Failure Triggered at replica: ' + str(self._id)))
                os._exit((- 1))
                return
            if ('drop()' in self._state.failureInjections):
                self.output((('Drop Failure Triggered at replica: ' + str(self._id)) + ' during sending the completed checkpoint shuttle backward'))
                self._state.failureInjections['drop()'] -= 1
                if (self._state.failureInjections['drop()'] == 0):
                    self._state.failureInjections.pop('drop()')
                return
            if ('increment_slot()' in self._state.failureInjections):
                self.output(('Increment Slot Failure Triggered at replica: ' + str(self._id)))
                self._state.failureInjections['increment_slot()'] -= 1
                if (self._state.failureInjections['increment_slot()'] == 0):
                    self._state.failureInjections.pop('increment_slot()')
                if self._state.isHeadFlag:
                    self._state.slotNo = (self._state.slotNo + 1)
            if ('extra_op()' in self._state.failureInjections):
                self.output(('Extra Operation Failure Triggered at replica: ' + str(self._id)))
                self._state.failureInjections['extra_op()'] -= 1
                if (self._state.failureInjections['extra_op()'] == 0):
                    self._state.failureInjections.pop('extra_op()')
                self.execute_operation('put', 'a', 'a')
            if self.check_validity_of_checkpoint_proof(completed_checkpoint_shuttle.checkpoint_proof):
                self.output(('Completed Checkpoint shuttle verified at replica: ' + str(self._id)))
                self.output(((('Truncating history for replica: ' + str(self._id)) + ' upto Slot:') + str((completed_checkpoint_shuttle.checkpoint_slot - 1))))
                self._state.historyoforderproofs = self._state.historyoforderproofs[self._state.checkpt_interval:]
                self._state.historyofcheckpointproofs.append(completed_checkpoint_shuttle.checkpoint_proof)
                if (self._state.isHeadFlag == True):
                    self.output(('Checkpointing Process Completed at replica: ' + str(self._id)))
                else:
                    if ('drop_checkpt_stmts()' in self._state.failureInjections):
                        self.output(('Drop Checkpoint Failure Triggered at replica: ' + str(self._id)))
                        self._state.failureInjections['drop_checkpt_stmts()'] -= 1
                        if (self._state.failureInjections['drop_checkpt_stmts()'] == 0):
                            self._state.failureInjections.pop('drop_checkpt_stmts()')
                        completed_checkpoint_shuttle.checkpoint_proof = completed_checkpoint_shuttle.checkpoint_proof[(int((len(self._state.replicaPublicKeys) / 2)) + 2):]
                    self.output(((('Sending completed checkpoint Shuttle to Predecessor Replica: ' + str(self._state.predecessorReplica)) + ' from ') + str(self._id)))
                    self.send(('completed_checkpoint_shuttle', self._id, completed_checkpoint_shuttle), to=self._state.predecessorReplica)
            else:
                self.output(('Sending Reconfiguration Request to Olympus due to invalid checkpoint proof from Replica ' + str(self._id)))
                self.send(('Reconfiguration request from replica', self._id), to=self._state.olympus)
        else:
            self.output((('No backward sending of checkpointing as Replica ' + str(self._id)) + ' is immutable now'))
    _Replica_handler_4002._labels = None
    _Replica_handler_4002._notlabels = None

    def _Replica_handler_4674(self, operation_object, client, signed_workload, p):
        self.output(((((((('Received retransmitted request of client: ' + str(client)) + ' for operation: ') + str(operation_object)) + ' on replica: ') + str(self._id)) + ' for requestId: ') + operation_object.requestId))
        requestId = operation_object.requestId
        if (not (requestId in self._state.requestIdToForwardedRequests)):
            self._state.requestIdToForwardedRequests[requestId] = 1
        else:
            return
        if (self._state.state == State.ACTIVE.value):
            if (requestId in self._state.requestIdToResultShuttle):
                (result, shuttle) = self._state.requestIdToResultShuttle[requestId]
                self.send(('Retransmitted Response', result, operation_object, shuttle.result_proof, self._id, 'VALID', signed_workload), to=client)
            elif (self._state.isHeadFlag == False):
                self.send(('Retransmit To Head', operation_object, client, signed_workload), to=self._state.head)
                super()._label('_st_label_4781', block=False)
                _st_label_4781 = 0
                self._timer_start()
                while (_st_label_4781 == 0):
                    _st_label_4781 += 1
                    if ((requestId in self._state.inProcessRequestIds) and (self._state.inProcessRequestIds[requestId] == 0)):
                        (result, shuttle) = self._state.requestIdToResultShuttle[requestId]
                        self.send(('Retransmitted Response', result, operation_object, shuttle.result_proof, self._id, 'VALID', signed_workload), to=client)
                        _st_label_4781 += 1
                    elif self._timer_expired:
                        self.output(((('Timeout detected at non-head ' + str(self._id)) + ' for requestId: ') + requestId))
                        self.output(('Sending Reconfiguration Request to Olympus from Non-Head ' + str(self._id)))
                        self.send(('Reconfiguration request from replica', self._id), to=self._state.olympus)
                        _st_label_4781 += 1
                    else:
                        super()._label('_st_label_4781', block=True, timeout=self._state.nonhead_timeout)
                        _st_label_4781 -= 1
            else:
                self.execute_retransmitted_request_at_head(operation_object, client, signed_workload)
        elif (self._state.state == State.IMMUTABLE.value):
            self.output((('Replica ' + str(self._id)) + ' is immutable now'))
            self.send(('Retransmitted Response', None, operation_object, None, self._id, 'ERROR', signed_workload), to=client)
    _Replica_handler_4674._labels = None
    _Replica_handler_4674._notlabels = None

    def _Replica_handler_4874(self, operation_object, client, signed_workload, p):
        self.output(((((('Forwarded request received on head:' + str(self._id)) + ' for operation:') + str(operation_object)) + ' from replica: ') + str(p)))
        if (self._state.state == State.ACTIVE.value):
            requestId = operation_object.requestId
            if (not (requestId in self._state.requestIdToForwardedRequests)):
                self._state.requestIdToForwardedRequests[requestId] = 1
                cid = requestId.split(':')[0]
                try:
                    self._state.forwardedmessageforclient[cid] += 1
                except KeyError:
                    self._state.forwardedmessageforclient[cid] = 0
                m = self._state.forwardedmessageforclient[cid]
                failurekey = (((('forwarded_request(' + str(cid[1:])) + ',') + str(m)) + ')')
                if (failurekey in self._state.failures):
                    try:
                        self._state.failureInjections[self._state.failures[failurekey]] += 1
                    except KeyError:
                        self._state.failureInjections[self._state.failures[failurekey]] = 1
                if any((key.startswith('sleep') for key in self._state.failureInjections)):
                    sleep = [key for key in self._state.failureInjections.keys() if ('sleep' in key)][0]
                    self.output(('Sleep Time Failure Triggered at replica: ' + str(self._id)))
                    self._state.failureInjections[sleep] -= 1
                    if (self._state.failureInjections[sleep] == 0):
                        self._state.failureInjections.pop(sleep)
                    sleeptime = sleep[(sleep.find('(') + 1):sleep.find(')')]
                    time.sleep(int(sleeptime))
                if ('crash()' in self._state.failureInjections):
                    self.output(('Killing Replica Failure Triggered at replica: ' + str(self._id)))
                    os._exit((- 1))
                    return
                if ('drop()' in self._state.failureInjections):
                    self.output((('Drop Failure Triggered at replica: ' + str(self._id)) + ' when receiving the forwarded request from some replica at head'))
                    self._state.failureInjections['drop()'] -= 1
                    if (self._state.failureInjections['drop()'] == 0):
                        self._state.failureInjections.pop('drop()')
                    return
                if ('increment_slot()' in self._state.failureInjections):
                    self.output(('Increment Slot Failure Triggered at replica: ' + str(self._id)))
                    self._state.failureInjections['increment_slot()'] -= 1
                    if (self._state.failureInjections['increment_slot()'] == 0):
                        self._state.failureInjections.pop('increment_slot()')
                    if self._state.isHeadFlag:
                        self._state.slotNo = (self._state.slotNo + 1)
                if ('extra_op()' in self._state.failureInjections):
                    self.output(('Extra Operation Failure Triggered at replica: ' + str(self._id)))
                    self._state.failureInjections['extra_op()'] -= 1
                    if (self._state.failureInjections['extra_op()'] == 0):
                        self._state.failureInjections.pop('extra_op()')
                    self.execute_operation('put', 'a', 'a')
                self.execute_retransmitted_request_at_head(operation_object, client, signed_workload)
    _Replica_handler_4874._labels = None
    _Replica_handler_4874._notlabels = None

    def _Replica_handler_5251(self, head, tail, id, replicas, olympus):
        self.output(((('Received become active request from olympus:' + str(olympus)) + ' on replica: ') + str(self._id)))
        self._state.state = State.ACTIVE.value
        self._state.head = head
        self._state.tail = tail
        index = int(id[1:])
        self._state.Id = id
        if (index == 0):
            self._state.isHeadFlag = True
            self._state.successorReplica = replicas[1]
        elif (index == (len(replicas) - 1)):
            self._state.isTailFlag = True
            self._state.predecessorReplica = replicas[(index - 1)]
        else:
            self._state.successorReplica = replicas[(index + 1)]
            self._state.predecessorReplica = replicas[(index - 1)]
        self.send(('Initialize History Done', self._id), to=olympus)
    _Replica_handler_5251._labels = frozenset({'yieldInitializeHistory'})
    _Replica_handler_5251._notlabels = None

    def _Replica_handler_5373(self, olympus):
        self.output(('Recieved wedge request from olympus on replica: ' + str(self._id)))
        self._state.wedge_request += 1
        if True:
            self._state.state = State.IMMUTABLE.value
            history_to_send = copy.deepcopy(self._state.historyoforderproofs)
            failurekey = (('wedge_request(' + str(self._state.wedge_request)) + ')')
            if (failurekey in self._state.failures):
                try:
                    self._state.failureInjections[self._state.failures[failurekey]] += 1
                except KeyError:
                    self._state.failureInjections[self._state.failures[failurekey]] = 1
            if any((key.startswith('sleep') for key in self._state.failureInjections)):
                sleep = [key for key in self._state.failureInjections.keys() if ('sleep' in key)][0]
                self.output(('Sleep Time Failure Triggered at replica: ' + str(self._id)))
                self._state.failureInjections[sleep] -= 1
                if (self._state.failureInjections[sleep] == 0):
                    self._state.failureInjections.pop(sleep)
                sleeptime = sleep[(sleep.find('(') + 1):sleep.find(')')]
                time.sleep(int(sleeptime))
            if ('crash()' in self._state.failureInjections):
                self.output(('Killing Replica Failure Triggered at replica: ' + str(self._id)))
                os._exit((- 1))
                return
            if ('drop()' in self._state.failureInjections):
                self.output((('Drop Failure Triggered at replica: ' + str(self._id)) + ' when receiving the wedge request from olympus'))
                self._state.failureInjections['drop()'] -= 1
                if (self._state.failureInjections['drop()'] == 0):
                    self._state.failureInjections.pop('drop()')
                return
            if ('truncate_history' in self._state.failureInjections):
                truncate = [key for key in self._state.failureInjections.keys() if ('truncate_history' in key)][0]
                self.output(('Truncate History Failure Triggered at replica: ' + str(self._id)))
                self._state.failureInjections[truncate] -= 1
                if (self._state.failureInjections[truncate] == 0):
                    self._state.failureInjections.pop(truncate)
                truncate_count = int(truncate[(truncate.find('(') + 1):truncate.find(')')])
                history_to_send = history_to_send[:(- truncate_count)]
            if ('increment_slot()' in self._state.failureInjections):
                self.output(('Increment Slot Failure Triggered at replica: ' + str(self._id)))
                self._state.failureInjections['increment_slot()'] -= 1
                if (self._state.failureInjections['increment_slot()'] == 0):
                    self._state.failureInjections.pop('increment_slot()')
                if self._state.isHeadFlag:
                    self._state.slotNo = (self._state.slotNo + 1)
            if ('extra_op()' in self._state.failureInjections):
                self.output(('Extra Operation Failure Triggered at replica: ' + str(self._id)))
                self._state.failureInjections['extra_op()'] -= 1
                if (self._state.failureInjections['extra_op()'] == 0):
                    self._state.failureInjections.pop('extra_op()')
                self.execute_operation('put', 'a', 'a')
            wedgedMessage = WedgedMessage()
            wedgedMessage.history = history_to_send
            wedgedMessage.checkpoint_history = self._state.historyofcheckpointproofs
            self.output((('Sending wedge response from replica: ' + str(self._id)) + ' to olympus'))
            self.send(('Wedge response', wedgedMessage, self._id), to=olympus)
    _Replica_handler_5373._labels = None
    _Replica_handler_5373._notlabels = None

    def _Replica_handler_5787(self, operations, olympus):
        self.output(((('Recieved catch up operations: ' + str(operations)) + ' from olympus on replica: ') + str(self._id)))
        self._state.catch_up += 1
        failurekey = (('catch_up(' + str(self._state.catch_up)) + ')')
        if (failurekey in self._state.failures):
            try:
                self._state.failureInjections[self._state.failures[failurekey]] += 1
            except KeyError:
                self._state.failureInjections[self._state.failures[failurekey]] = 1
        if any((key.startswith('sleep') for key in self._state.failureInjections)):
            sleep = [key for key in self._state.failureInjections.keys() if ('sleep' in key)][0]
            self.output(('Sleep Time Failure Triggered at replica: ' + str(self._id)))
            self._state.failureInjections[sleep] -= 1
            if (self._state.failureInjections[sleep] == 0):
                self._state.failureInjections.pop(sleep)
            sleeptime = sleep[(sleep.find('(') + 1):sleep.find(')')]
            time.sleep(int(sleeptime))
        if ('crash()' in self._state.failureInjections):
            self.output(('Killing Replica Failure Triggered at replica: ' + str(self._id)))
            os._exit((- 1))
            return
        if ('drop()' in self._state.failureInjections):
            self.output((('Drop Failure Triggered at replica: ' + str(self._id)) + ' when receiving the catch up request from olympus'))
            self._state.failureInjections['drop()'] -= 1
            if (self._state.failureInjections['drop()'] == 0):
                self._state.failureInjections.pop('drop()')
            return
        if ('increment_slot()' in self._state.failureInjections):
            self.output(('Increment Slot Failure Triggered at replica: ' + str(self._id)))
            self._state.failureInjections['increment_slot()'] -= 1
            if (self._state.failureInjections['increment_slot()'] == 0):
                self._state.failureInjections.pop('increment_slot()')
            if self._state.isHeadFlag:
                self._state.slotNo = (self._state.slotNo + 1)
        if ('extra_op()' in self._state.failureInjections):
            self.output(('Extra Operation Failure Triggered at replica: ' + str(self._id)))
            self._state.failureInjections['extra_op()'] -= 1
            if (self._state.failureInjections['extra_op()'] == 0):
                self._state.failureInjections.pop('extra_op()')
            self.execute_operation('put', 'a', 'a')
        for so_pair in operations:
            tslotNo = so_pair[0]
            operation = so_pair[1]
            opstr = operation.split(';')
            requestId = opstr[0]
            clientId = requestId.split(':')[0]
            operation_object = Operation()
            operation_object.requestId = requestId
            operation_object.slotNo = tslotNo
            operation_object.command = opstr[1]
            operation_object.key = opstr[2]
            operation_object.value = opstr[3]
            output = self.execute_operation(opstr[1], opstr[2], opstr[3])
            result_hash = self._state.utils.getHash(output)
            result_statement = ResultStatement()
            result_statement.operation = operation_object
            result_statement.result = result_hash
            signed_result_statement = self._state.utils.getSignedStatement(self._state.replicaPrivateKey, str(result_statement))
            self._state.lastresultstatement[clientId] = (output, signed_result_statement, operation_object)
        self.output(('Sending caught up response from replica ' + str(self._id)))
        state_hash = self._state.utils.getHash(str(self._state.runningstate))
        self.send(('Caught up', state_hash, self._state.lastresultstatement, self._id), to=olympus)
    _Replica_handler_5787._labels = None
    _Replica_handler_5787._notlabels = None

    def _Replica_handler_6238(self, olympus):
        self.output(('Sending running state to olympus from replica: ' + str(self._id)))
        self._state.get_running_state += 1
        failurekey = (('get_running_state(' + str(self._state.get_running_state)) + ')')
        if (failurekey in self._state.failures):
            try:
                self._state.failureInjections[self._state.failures[failurekey]] += 1
            except KeyError:
                self._state.failureInjections[self._state.failures[failurekey]] = 1
        if any((key.startswith('sleep') for key in self._state.failureInjections)):
            sleep = [key for key in self._state.failureInjections.keys() if ('sleep' in key)][0]
            self.output(('Sleep Time Failure Triggered at replica: ' + str(self._id)))
            self._state.failureInjections[sleep] -= 1
            if (self._state.failureInjections[sleep] == 0):
                self._state.failureInjections.pop(sleep)
            sleeptime = sleep[(sleep.find('(') + 1):sleep.find(')')]
            time.sleep(int(sleeptime))
        if ('crash()' in self._state.failureInjections):
            self.output(('Killing Replica Failure Triggered at replica: ' + str(self._id)))
            os._exit((- 1))
            return
        if ('drop()' in self._state.failureInjections):
            self.output((('Drop Failure Triggered at replica: ' + str(self._id)) + ' when receiving the get running state request from olympus'))
            self._state.failureInjections['drop()'] -= 1
            if (self._state.failureInjections['drop()'] == 0):
                self._state.failureInjections.pop('drop()')
            return
        if ('increment_slot()' in self._state.failureInjections):
            self.output(('Increment Slot Failure Triggered at replica: ' + str(self._id)))
            self._state.failureInjections['increment_slot()'] -= 1
            if (self._state.failureInjections['increment_slot()'] == 0):
                self._state.failureInjections.pop('increment_slot()')
            if self._state.isHeadFlag:
                self._state.slotNo = (self._state.slotNo + 1)
        if ('extra_op()' in self._state.failureInjections):
            self.output(('Extra Operation Failure Triggered at replica: ' + str(self._id)))
            self._state.failureInjections['extra_op()'] -= 1
            if (self._state.failureInjections['extra_op()'] == 0):
                self._state.failureInjections.pop('extra_op()')
            self.execute_operation('put', 'a', 'a')
        self.send(('Running state', self._state.runningstate), to=olympus)
    _Replica_handler_6238._labels = None
    _Replica_handler_6238._notlabels = None

    def _Replica_handler_6535(self, olympus):
        self.output((('-----------Killing replica: ' + str(self._id)) + '-----------------'))
        os._exit((- 1))
    _Replica_handler_6535._labels = None
    _Replica_handler_6535._notlabels = None
